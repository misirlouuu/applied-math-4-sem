# -*- coding: utf-8 -*-
"""lab2 applied math.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mAouVTQhm2rl8pDCMSd7vRafgoc3ldSp
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import *
from matplotlib.patches import *
import scipy.integrate.quadpack
import math
import matplotlib as mpl
import prettytable as pt

"""# **Вариант 3 Биржевые котировки**
# Кумирова, Харлунин, М32021

![японские свечи.jpg](data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wBDAAcFBQYFBAcGBgYIBwcICxILCwoKCxYPEA0SGhYbGhkWGRgcICgiHB4mHhgZIzAkJiorLS4tGyIyNTEsNSgsLSz/2wBDAQcICAsJCxULCxUsHRkdLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCwsLCz/wgARCAIZBAADASIAAhEBAxEB/8QAGwABAAIDAQEAAAAAAAAAAAAAAAECBAUGAwf/xAAaAQEAAwEBAQAAAAAAAAAAAAAAAQMEBQIG/9oADAMBAAIQAxAAAAH5+LPIAAAAAAAAAAAAAAAAkiZkiQAAAAAAAAAAAAAAAAAAAAAAAARIrF4KpgAAAAAAAAennJcCYEokTAlAnzt5gAAAAAAAAAAAAAAAAABaSJAAAAAAAAAAAAAAAAAAAAAAAAAAAABEii8FQAAAAAAAWt5yXAAmBMRQAAAAAAAAAAAAAAAAAJkiwkAAA7LwhygkAAAAAAAAAAAAAAAAAAAAAANyjTNvqAEgAK2FFoRAAAAAAAEwLKiYAAAAAAAAAAAAAAAAABZICQAAANt3mi2Hlrtlj86brZa7anO9RxXUGBHt5mx0e/5I6CvtQvr8DXnach2WKYPPdFysu3wtnrIbvx1oZWNlmPod/pjdevn6nO9LzXUGjzPHpSeP2usNrwXf8DLsYvSGVsdfsYaHca3YSryHn0R6bLX7Q0GXpu4KfKe74SQSAAAAit4RUAAAAAAAAAAAAAAAAAAAAAAAACyQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACK3gqAAAAAAAAAAAAAAAAAAAAAABaLAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEVvUgAAAAAAAAAAAAAAAAAAAACYsSAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACsWqAAAAAAAAAAAAAAAAAAAATYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFbCgAAAAAAAAAAAAAAAAAAExYkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFYtUAAAAAAAAAAAAAAAAAAm0SAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAK2gqAAAAAAAAAAAAAAAAAC0gAAAAAAAAAAAAPQ8wATHWamGpbWJatsoNcysU3HpuceJ0NelyTlcbpbnO+PZ4hzVOt8zlfDf6BAy5YjYya1s7GqnbbOHKiReiQQAAAAAAAAAAAAiRQAAAAAAAAAAAAAAAACYksAAAAAAAAArBdQXUF1Bfa6fbQ19FJXUG31dBdQXUF1BdQXUF1BeYGXiAAAAVg9NjqhdWxstbstb4vD3QAAAAAAAIJUF1JLAAArEwAAAAAAAAAAAAAAAAJiSwAAADIzTVLwVelCE+h5RaCiYAAAG21O2hrKXpIAD2zMLLMZAlAlAlAm1LFlRZUWVFlRna3Y6wqABasm01uy1vi8PdAAAA2RrWzwTyWseaZK09vMqvQAm1LEgArEwAAAAAAAAAAAAAAAAJiSwAAAMvreHQ+keXzwnusrhsQ7vB5Id/6/OxvNBMTAB7ZBggbbU7aGt8/TzkAAABs/OPQ8Le0Hh55ApeZh43rEz6eeRWI8/DNonCImFQAAWixstbstb4vD3QAZ2MeQHT8wh1eVxQ7nZ/M8tPY+HFVR2e6+Yk/QeNwYQEptEgAFYmAAAAAAAAAAAAAAAABMSWAAAB7ZWvGwa8bGdaNk1o2c6tDaNWltWqQ3WXzcEdfyPb0Yq+nuyczFjLGl5jr+R2dWEr9cJEJEJEJEJEJAAACs1AAGVi5sWdNOS5/0vjTJJxtB1HN24tSNnC6bC00w2saobWNWNm1g2TWxLYxrRsWuGwxfELRYAAArEwAAAAAAAAAAAAAAAAJiSwAAAAAAAAAAAHb8R2+bBkJZOZCRreR67kdvVC/aAAAAAAAAiakAAAZ2Hm+beuHP+oAc30nN24dSNvAAAAAVmoAAJJkAAAKxMAAAAAAAAAAAAAAAACYksAAAAABW1QgSgSgSgSgT3PC91mwZIycwDW8h13H7etdE37AAAAAAABAqAACYuMzDy/NvXjn/UAOa6XmrsOpVbOBZWSwAETUgAAE2iQAAACsTAAAAAAAAAAAAAAAAAmJLAAAAAARIoAAAAB3XC91mwZAycwDW8f2HH7etNqXv2AAAADJMZ6eYArNQAASTIMvEy/NvXjn/UAOa6XmrcOnG3gLxIAIFQAATFwAAAACsTAAAAAAAAAAAAAAAAAmJLAAAAAAVmCAAAAAO64Xus2DISycyEjWcf2HIbetMl+wep5PTzAAGbhDZ+uoQ2ttPEqgAAXZJjAZeJl+bevHP+oAc10vNW4dPMX28AABWagAAkmQAAAAArEwAAAAAAAAAAAAAAAAJiSwAAAAAAAAAAAHb8R2+bBkjJzANbyPXcjt6oX7W01ZOfXErEZrCSzWEM1hDNYQzK4cGawhmsIZs4NjOy9QhAkysTK829iOf9QA5rpebtw6iTbwABUgAAC8SAAAAAAViYAAAAAAAAAAAAAAAAExJYAAAAAAAAAAADt+I7fNgyRk5gGt5HruR29UL9oAAAACs1AABJMgAKjLw8zzb2I5/wBQA5vpObtw6kbeABFQAATFwAAAAAACsTAAAAAAAAAAAAAAAAAmLEgAEEQAAAAAAAADuuF7rNgyRk5gGs4/sOP29ZMWv2SAAAAQRAAALJAAIrMDMw8zzb2I5/1ADnOj5u3DqRt4Cs1AABJMgAAAAAABWJgAAAAAAAAAAAAAAAATElgARW9SAF9yaMAAAAAADuuF7rNgyRk5gGt47sOP29abUvfsAAAAiswAAJixIAETBUDMw8zzb2I5/wBQA5vpObtw6kjbwIgABmmFbOwgAAAAAAACsTAAAAAAAAAAAAAAAAAmJLAARIosN3n8r6w7C/EE937cdhHbePH1Oz2PzqTqOT9aTFVhVkephd1w/cZsGQlk5kJGs4/seQ29asyv2SAABEwVWFUwCRYAAAIreCuZi5nm3rxz/qAHN9JzduHUVs28CrO8DwA2Wt9TvY4SYnu/T5/mnWePG1Ot6P5dY7nltfRASAAArEwAAAAAAAAAAAAAAAAJiSwAAAPbK142DXjYtcNk1o2bWDaNWNq1SG4z+boNnrEedtnc3tfFV66ykzsNee7An0AAm21Tp20iI1jb+Br67aJam22xDFbRDVs+0tcAABehO0at4v6DDrrfF20wvBZnD1T1Gv1FobGNZWW1nVjZtYNk1o2LXDYNeNhi+IAAAArEwAAAAAAAAAAAAAAAAJgXAAAAAAAAAAAAA2uq2sNbS9JAAJjbGt881DDvkjxexOPb2HjTJHh55Y8Leoxfe4wmamMO+TmQ0wkABstbstb4vD3QAAAAAAAAAAAABWAAAAAAAAAAAAAAAAAAtMSAAAAAAAAAAAANrqtrDW0vSQAC1R6eYAAAAAAAAT6eQAAA2Wt2Wt8Xh7oAAAAAAAAAAAARMFQAAAAAAAAAAAAAAAAATalwAAAAAAAAAAABtdVtYa2l6SAN3qoeL1S8noPNaplOl2MT8/drnHzx3GUfPXb+pwbtss+fPfwmBco9B5vUeT32cNKJbLW7LW+Lw90AAAAAAAAAAAAKzUAAAAAAAAAAAAAAAAAATAuAAAAAAAAAAAB7eImAA6bVa5DPYCWdGEMjHCyotbzF1BbMwScrHqQAyMcZs4Iz2ANlsubQCXr5CQQAAAAAAAAAAABWAAAAAAAAAAAAAAAAAAAAm1LEgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVmoAAAAAAAAAAAAAAAAAAAAmBdEgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgiAAAAAAAAAAAAAAAAAAAAAAWqLokAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAECoAAAAAAAAAAAAAAAAAAAAAAALVF0SAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACBUAAAAAAAAAAAAAAAAAAAAAAAAAFqi6JAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIqAAAAAAAAAAAAAH/8QAMRAAAQMCBAMHBQACAwAAAAAAAgEDBAAFExQgNBESYBAVJDAzNUAGITEyUCOgIiVE/9oACAEBAAEFAuu1/PXy9bIvk/jr/j15xrjXH+gFhQGpViNpj+fEjxpDExiNHb6NiMpOes8QIkiDHbT6nYuTb10cgBL+pXH3GXr1Bbiu3q3tPRrBBAiyATPqQ5DjT13gNxZd+t7rktIis/TFquDcuVc7kHNOthy7e/bpMJz6kbBuZAYGTPm3Bi3Sr+gYdxlt24EfbnWKBHjw7VEmxbs7ZogtXo7ZMx75FFy6y5UWzuT5USUt5tjkiddnWI7d2YRbdb7axEjWiQxxWKzY45KpFbo0eNbO+Ikhuyj/ANVF8WNmgNOiy6cp61wm496iMl3rcIQyfqN9w4j16gtttXmPxZjW6PEgdGpZostpkIlhbtAi1VrPjeXJwQ/qZ2M/IduZKkm5XDKXwrg0/eM+EP6ldiyHnZ5Lnr7cn2JebKT9MWEkG73FUW5zYuft8txqLZ/qUxObHRwpFzuoxiv7ovNfUJiY28xT6bgPR5tphwGLS9ZpSPXs7vOx75JRq6y4Ue8OT4kaGt4ujsSdd2WJLTk6NEtdjkq69aIzKUkpq+xiFQO3SI8u19yx47dkXjaYaPRDtNwYAsnKAs4+zNj3+Y9KuEwYv1I+07McuqkByp8eJBs8jnZ/2WeHHyJ9vKDUi2OMR34MmMOUfxgt8txlWHUFYUhDBh1xvKv5k47rbbjLjKeR+OoAAnC0MwzjRu7nq7vdrIO1kXayTlORzaGnblHzGbZktyHWBtc2ZGlG+TUs88wxbDuLbU85kXJG+KWxJsXJ3OUktOxuObo5Jysi7WQdru92kt76LJhk/F7OVeXpy278/wB+1iSOH5yLwV+U9JXyU4cZElCDsD27py2b8/3/AIIe3dAJ8y2b8/U0ttk6brS8MB2sB2sB2sB2sB2sB2sB2sB2sB2sB2sB2sB2sB2sB2sB2sB2sB2sB2gZVxskUV1B7d0Sw1juvwDZYUCROVeKNmtcFpEVawnK4LXKSl+F8i2e4H6mltwmjdc4piuViuViuViuViuViuViuViuViuViuViuViuViuViuViuViuViuViuUD2E2SqRah9u8qNBckhIgPRxwzSuVawz4cF4IJLStmlcpcyCRfzU8mM0Tz74KlsfQsrzNKTSTe5U5DnBHZjgk+T3HzsMIJCr13Pmk+RbN+fqeSLSYBsf58BeKx6y68FaVEy6ouXXmNrkEGEMMD7YJIgsKVKKj5Ye3eU0CzrQuJbLXJluk7NVs2nc7mhBp6DJQIUCXMeJEOOxeIi8bfNITnf2CkmcbyWsPFkxljl22z3A/U8lHG1ZzSIaOob5OtgeMHJmSQcwnMklMRx3nabNAAJCYaSFFEk/8AI3hVryg9u0xoyvq5yYuuRJOSf9ptxWlzZVnCrOFWcKs6VZ0qzxVnirPHWeKs+VZ86z503MddcnykSPTEdlY+WZoWWwLLM1lmamsNDF+ZGFCkZdmsuzWC3y5dmsuzU4BB7sgyuaMc11s+8DrvA6z51nzrPHWeKs8VZ0qzpVnSrOFWcKs4VOOK6XQSKor2R9ton7P5kTdabj6/aqqS/GX+Gnyo+20T9n8yLutNx9f5S/3WNton7P5kXdabj6/yl/hp53GuNca41xrjXGuNca41xrjUfbaJ+z+ZF3Wm5ev/AHU+VH22ifs/mRd1puXr9Lx9ton7P5kXdabj6/S8fbaJ+z8wGDcQwUF86LutNy9fpePttE/Z+ZF9WP6P/oQsRtefl8uLutNx9fpePttE/Z6G21cI0FD18eFcV7FVdafl1rk0Rd1puPr9Lx9ton7PRGcHDJ3lLHGscaxxrHGscaxxrHGscaxxrMDWONY41jjWONY41jjWONY4044jcfti7vTcvX6Xj7bRP2elVUl+D+KVVVe2Ju9Nx9fpdjbaJ+z+ZE3em4+v0uxttE/Z/MibrTcfX6Xj7bRP2fzIm603H1+l4+20T9n8yJu9Nx9fpePttE/Z/MibvTcfX6GACcMrRLEfPj7bRP2fzIm603H19caK5KKRDeiL/ds7gNXKFb5jFzjz3CZj5d+FHSXhtCRSo8BoZUOW8gNC3Js/+F243VeMXVH22ifs/mRN1puPr64TBuuGwrlSxVy3TgbQlzohgMEy6wMCFMmPrbsOOxf4actsuPJn/wCqrhqP3SvvwCY4EbnLnUzVeK1xXhxWiIjXtaEFdkRijuVH22ifs/mRd1puPr9kaMUg3EBHO0SUFUyIlcMq5y5n5jjyC4YVzLXFeHOXMJkH9Zs0bLMjWZCsyFZoKzQVmgrNhWbCs2FZwKzgVnArON0MoTKfIAIlBPdAO8XqiTHH5JXF5C7xep2Y4835HD7/AAwNWz7wervB6hluLE7wervB6nXieLshPg5DKWIlnG6zgVnArNhWbCs2FZsKzQVmgrNBWZCsyFZkacNDLoIDJstFt35/v5IfuQt5xWsRSbaGsonBGhcDABCNocM2RQWORXEbbKhabJ/A5WHI6c/lD7dpReCkRGXStt35/vqRFJTBWzr8KrhK5jHSPGNYhcpOkVI6SViFwV01USUSF0hLGPEQ1Qcw52p91MCbLUPt3Tlt35/vqi8mF4avDV4avDV4avDV4avDV4avDV4avDV4avDV4avDV4avDV4ajwsnqH27py278/31CSiRnzn8FPsrjhOlqH27py278/3/AII+3dOW3fn+/ljGdOMxGdkfFH27py278/37WIqNs4TlYTlYZ1hnWGdKJJ2W6Qka0xsGNWEwNqeBlZ4NsIzhR2HsGPJt7j0fNAykKUyETvJ/cdiCS1hnWGdYZ1hOUjZosiKhNdge3dONOky4v3XtjzTfYWdKrPSazsms7IrOSKN91xK5l5UJRrmVUxDWuckrnLiqqtMPi2T8lyRJRVQu0H3Wxzkis7IrOyaz0mknSlWTNNpjsxCRv/Wv/8QAKREAAAUCBQQCAwEAAAAAAAAAAQIDBDIQUAAwMTNRESFAcRITFGCAkP/aAAgBAwEBPwH/ADWHwldC+rcPhK6F9W4fCV0L6trwRAodMfM3OPmbnDQREnfOSmGPrLxj4F4w8IUEuwWx7EKs4ZyUwq+2rY9iFWcM5KYVfbVsexCrOGclMKvtq2PYhVnDOSmFX21bHsQqzhnJTCr7atj2IVZwzkphV9tWx7EKs4ZyUwq+2rY9iFWcM5KYVfbVsexCrOGclMKvtq2GIBtcCiTjH0J8YKUC9gzgHpj8hXnCi6gdO+DLHOHQw20fCV0L6tw+EroX1bh8JXQvr9A69f5Y/8QAJxEAAAQGAgEEAwAAAAAAAAAAAQIDMQAQETAyUCBBQBITIYAiYHD/2gAIAQIBAT8B/idf0ULocw+9Qt4Re9cLeEXvTUnTiLeEXvnSVNIuPxFRiowjjeM0VGKjCQ/lrF2mhjeM00stYu00MbxmmllrF2mhjeM00stYu00MbxmmllrF2mhjeM00stYu00MbxmmllrF2mhjeM00stYu00MbxmmllrF2mhjeM00sudIppBABeBTLHtlgAAGv+gsFIEAUA1o+EXvXD4Re9cNisVlXmXv7Mf//EAD8QAAEDAQQGBwcEAgEDBQAAAAEAAgMRBBIhMRMgMjNxkSJBUWBhcpIFFDA0QEKBEFBSsSNiQ6ChwRWQouHx/9oACAEBAAY/Av8A2pg+2WuOz16lp7PK20Rj+P7g9r5xDPXo3z0SFGyKbTS/eW7Pc65NahEGtwLz/wBk4R2+KYOGw0qSK6CxpdghZfcoaXy29RSQ0uxjE04IxQ+xr0DcN3mopYWlkcwrdPUU7QNaJoReo0Zhe9TgXK3GA9ZU0RF2JuJARii9jXrODTd4lQvibdjmxu9ijNmsxLbmNxqm00NyW99wx6lHZnWOEYbVPBWiyCyRNobt8Zqx+7sjBDel1dSZp46NJzzCiDGNb0OoeKihfsuOKNmisERDOsqxvZG1l9lTdHBWelkhffb1hWqb3aONzajAI+0LTHpXE0Y0r3WeyMYXDouarRBI0PuNOY8U6llkpe/irNDE1rNIKYDxQssFkZI4DpOeonwWfQyffTJQizQ0aRQuAwCbYLM1v+PbfTElezxFGL7x1DPAJ8cgZJaLt53XRGyWpjTHLgHUyKklluzTP6MYIRJzKd7RtMelxoxqey02FoFOiWZq1SNgbLI13RBbXqUot/s+OCJra37t1TWqSMzMi2WU2kIbT7IuQuwqIz0VarO8B4a2rbwUTHRnCUVFPFMs7QGNcBWi0Fl9kX4m4XjGekobXFEYRJtRnChVhZDEL7x9ozyU0ZuSThl5/XTuc11jtjcsQ9PkdMJrSRQNCk9q2iZuNcOtQvcaVfUqSY4xnA04Iy2X2tSF2O3khH74bU1vWTkVDMx15lyjqdlVZIrPRtlidh1KaVxrG7okhGSze1/8Jx28k2P3x1qY37iVG2zWijbmN1TmaW9Je68+pRlxAFDnwVoIxGkKsbY54mljcbzvBRWIztmmvDZNaYqK64O6HVxTBEbr64HsUcTWxWmUN6b3CqsbgW7GIHVkrJdcD0er8K2NLgCScPwv/T55BE8GrHFe9Wm1RuujohqtE7yGX2nPinAWl1Lyss0ZD9GK4HxQtVmtTGucOk1yibFaNLL99MlCYJQWUq5vUU32hZnDp7betWaY3XzMjAYK9dFbZZ5Bee3rKdbbU5ojixDe0qSGa7DOzpRlFrsxgnezrRIIjWrHFPfa7aylOjcVqjZM2KRzuiSadSdJbvaMckV3ZL7ytFmc8wxyklj8rqvSe2aQ9t9Gdk5e8YX+0KGNxja0vAdQJloHSaAK0WmsXtW7G77S/JNh9+dahmca0Khm6Mk4ZRgVvfNJ03jrOef/AFLWHwIjW8yRtQVZnYmSf7KZIOliLQetPi0ZvsFXDsWlZA8s7VGSw0k2fFSN0Tr0Qq4didI1hLGZnsXu+jOl/imSPYQx+ye1MMjC2+Lw8R3pusFTqiRlwzSDAl2ytqP1raj9a2o/UtqP1LNnqVXFv4P6XJRpobjXCnU8BWM2qX/lc6SnUp4WvgvF4IEZJ/tWuFjmRl1CJB/yeBTLQ22tgDYw25jebh1KzOYb9qY0tb/pjmrdPHI115rbv+3arTZ7P0Iy2oBzc6qFtNRaXM93/wDvkrPZ5+nGI6kDqdVWd94F1zpAdWP63gW/krNnqW1H6ltR+pbUfrVQ6P1ozuuCZm1Q4O/W9TDu6z8/0ncdTQWjpRHI9bfj1GaBmkc+mVfhY5IQwi7C3/5eP6yebu6z8/0ncf2KTzd3Wfn+k7jrXWoMjiNB91M1u3clu3clu3clu3clu3clu3clu3clu3clu3clu3clu3clu3clu3clu3clu3clu3clu3clu3clcMZa4ZGmaoc9eTzdygy+xlet5oFphJHNHWl6M1oqlpAQFDisGnksslgFu3cllmrt017Fj8Fn5/pO4615qD2SEVzbXJbbua23c1tu5rbdzW27mtt3Nbbua23c1tu5rbdzW27mtt3Nbbua23c1tu5rbdzW27mtt3NXr5c85CuSqdeTzfDdICyONub3mgTX9GVjsnxmoWw7kjgcFsnkq0wWAJWw7kqUNexYNJp+7BrA0nOjjSqLJ2R2M6QXQw7XFW1krpJG3KtdI4UPiAoQw0tfuoEbjs//AKoBZXXZL7r2NCrS2jZZPdqSBppecpi0aJ77K+9HevXUXe8Pv6alb2NKKwTuo+XRtYxnZ4q3iK9pzL9jg1xb4JgdHdkayjquDieNPgs/P9J3H4THCK+Tnii1uAAqa9SbRwIcaVTqPa5zcwr1RcpW8mf7J1XABuFVS8KUvVQcHBwPYr2kaKZqpkaAcvFPr9iZjtrEEfDk83w47PCRpYnkllaXk6N0l20SPDmta7FnivZzTM4texhcK5mqtwshpJpKzVzc3w8FZTFIBZwxt/pCnjVTiGDTs95Ja0Ou4Kdtml2Z2kGuI6K9ntMziHsaX454qZjCHyzXi938RTJWb3XSG7tiOQNx8aqVzGBgvZA1/eY4DS7GSR+fhN0tbnXRAg343bLh16jPz/Sdx+Exjr/R7Fkbt274qMBz6XvuTy0Ovmo8Forpuf8AeqY1pIu5qQ02sgUHUybSnamtpiD1J4/kKINdfF3+KkpW87IqJzqkszVwXjU16Xw5PNrEk3Im7Tj1J2jrc6q/ADn0qGhuH73UBp4hbuL0rdxelbuL0rdxelbqL0LdQ+hbqH0LdQ+hbqH0Lcw+hbmH0LcwehbmD0IMZBCXH/Re6gMLvuLRgOH6MJjacFum8leawArdt5LdN5IlrAD9awHEVW7byW7byV24Kdi3beS3beSF0Uw/X3WkYf8AbeGBRY6CEOH+i3MHoW5h9C3MPoW6h9C3UPoW6h9C3UPoW6h9C3UXoW6i9K3UXpW7i9K3cXpVSGjgO4dQaH9Y/KNV31rOOs3hqVJqe6kflGq761nHWbw7sR+UarvrWcdZvl7sR+UarvrWcdZvl7sR+Uarvx9azjrN8vdiPyjVd9azjrN8vdiPyjVd+Pi1bTmqGn4+OzjrN8vdiPyjVd8U+UpxbW/XqFSr90i63pVURl/mpdKAGgYfEZx1m+XuxH5Rqu1aBUaajt+ixVQbzDkdRnHWb5e7EflGq7VMVBU9vWqGBgK3Ma3Ma3Ma3Ma3Ma3Ma3Ma3Ma3Ma3Ma3Ea3Ea3Ea3Ea3Ea3Ea3Ea3DFcLGhzvtHVqM46zfL3Yj8o1Xa1Sa/R1OozjrN8vdiPyjVd9azjrN4d2I/KNV31rOOs3h3Yj8o1XfWs46zeHdiPyjVd+PrWcdZvDuxH5Rqu+tZx1m8O44a0VccgibjSW4locCR+PoI/KNV31rOOs3h8Ahl0XcSXOom6QCjtlwNQf35heQ2oIDj1FMllaY2xuvPkOVFb3RuAZGKx9EYdJWZ9sdi6Z3VgT4r2idEDag5tBTLgvZzrUxotRcb2FCW+Khn0csJ04bdl+7grc0OFIWEs6IwxQtFrd0WzFz+12GSjfcDXmyh0bQOtR6WOXTXsHvYG1GvH5Rqu/H1rOOs3h8C8LObQ1m00Fez2BoshvGkTulTxQfKHl7ZgAZIw0q3my42ivTBGTfBWD3WJpjdE2/0Qa8VbmxxPljE4oIs1atE7Fro3C9m3wVk6Q/zB1/ojHFdIB80xwH8BRROs4ffLjpNHGHH81UujjMYrsnq/drpe4t7KrPNUrgpYc9LTpVxFFevOvdtVUvcSPFHE4qlTRDE4KrnF3HUaJCWs6yFQ4tOLXDr/SPyjVd9azjrN4frndaMXOPUnCMkt6idSrSQfBXi4k9qxe4/lVvGqjGxcjEeBzoui5zeBRxOKzyV68a9q6Li3h+7VLGv4r5eJfLRL5aJfLRL5aJfKxL5WJfKwr5SFfKQr5SFfKQr5OFBrbFCSfBCy6NmkzN3Jn6Bou4LJvJNjdShRFGrJvJXHUp9aHDML7V9qdJhUGi+1farzv1NmEbNJmA7J6INihBHgvk4OS+UhXykK+UhXysK+VhXysS+ViXy0S+WiXy0S+WiXy8SqGNZw7h3mmhHZqs/P8ASdx+EOKrpOleyopqDpX1FQXgcD4ql4VvUrVSEC7Q4VKiB6xjQ5oVj0fSpmpP8VLuTqoNcy9U9qeblLmFLyjGFHZgFPcSCRlQqjCK0rT4cnm1qhFzjUnr7rM/P9J3HXoM1dOf63/uzT8dvNNp9uSpXrqnV+7NN/1yVPGqca7WaDhmESDnmg/Co8EW9RXV2VpqXXa8nm7us/P9J3HXdnpPBZyLORZyLORZyLORZyLORZyLORZyLORZyLORZyLORZyLORZyLG9/rXPXk83d1n5/pO469RgUXUAr2fR1OvJ5u7rPz/Sdx/YpPN3dZ+f6TuPxHztbWNhoSn6Ntbjbx4fSyebu6z8/0ncdT3idhcPsZ/Jbt3JbDuS2HclsO5LYPJYgj9JXPbejMoa8doop7JZ3iSsL3uf29gVjtM9C1gd0P5mq9paTos0TchlkvZ2hJe02nNzaK3RUD5nRveT/AA7ArJC9zYnhl+/4VxVk/wAYbZ54tGR2CuCsdiNDIZb8n/gJlqF3/I+4Iux3WVJ5j+uDSVsu5LYdyWw7kth3JA6Nx/C94gaQz7mH7f1k83d0PZmFXU0BmMcg2HdvgVv3LfOW+ct65b1yo95I/S7XDsWBIQBJoMkemcc8UOkcMQibxqc0KnJVlhE46g4nBOncem41wVQcdSjHkBb1y3rlvnLfOQGndj4r3cSmV523/wDgfqY/tOP/AE2H/8QALBABAAIAAggFBQEBAAAAAAAAAQARITEgMEFQUWGh8RBAcbHwYIGR0eHBcP/aAAgBAQABPyHctSt51K8qYmsV7pVvevKDTq1Rz3RW+68nRg6lfume5q3/AF5IagjpPBuavoOvJWkvLy3Hc1StQFsrEGxp7qRqNrXNX+7wL1QujaPvClYq6xwDVVKrfAavhhYbDYtmJlcR++cw0e2WBjKY7wJeF8uUoapmawBhL0yxLs8cphhQKuVX3jNaiQVz9uksmYC2P8+VKlE5bhRhNsBI6eOUZtSsM94nWAStMhdvCYSpYaa3AhW+QuHomMnJCsDnlKS2qwbY/MeaTAtnKEyW9VbUdyqdOHCUyawc8L4RlkYqM4Psdmgqq5c4+jo1cB/2BF2UWdSwvVXEYKbIYw4KZZsTVsVcpGhkPVBgecY4y7A5KEj9w1WJtiRBsbkLlElTbOC4DjQp2BH48sC25y/322Fca95mhFsDlmHLOveOTthKPrshGcsNcGEDivgwvzLLUB2Vnl8zlyc0I+5qGl5QOFj/ALMvwH2M1xYzVNUArEWapD8q6zARGDistkPCo6AVUG2lRMRGq1ib2DWWTVNuv02ThR9Dy5esOwpz814wRawi+sUzDvjwRjLo4wL+2YFfuMNpCEKpu7sixCslF2sxEHmlFGMoCPS3h4Zw1gJVinbLAXawS7ZWG9CxgvYmZlWqhlBKU9ZX1vI5j9S9vrIHF/IklGdXtS8ynGq3G4aaVCL5VLxRSnDgTDq3drqK9FCcXBFWzqFxuYo5XsVh7hgKqwUQeIEGBlfpK+sUs9EMlgbSVOHFlEff/IVp1COJtmG2s8o8a95UTg7IhcrAI3VecDxQk4+lLJIVNFcP3D2p7ECq8gGd+8SlHAVq+m30ibAgPwYy/wAUOIfmBreTmYZ7NkyDmNXafmpajdHjstuyIbNKcLxigh628ERjfOFYfPKVWoxaomioXrpQuMeNm6rVrSb0D6NTeQfR6XvAPpFN3B9Ju7D6Vf8AgDuo+l3/AJQfTL/yYz+m3cp9Nu5TLcAlQtdRlzqrWO0i5xejiyV98YiPqFiXE0HyUcWYTqsBmcjbP5pT4RZ+kN4yt0HDtlPtH4+MuYLwYOA4r+TUVbhEVSUm4HL6AHtfIIlNOZoMfhRgPLixVtdeSdtTtmdozt+EGC6zfAKwGvwDkxxCMU4lcPtBwLX8Xne16S8WrsKHy9I09gsQUoGZKSApstmc+E9KEHSqe8yXJmoK/gw+022JhnWftR3Nek019zD7zHeo2jfD8eNZQusmdvztGdsztqGw0xGkoH3EaPHk+I7Dq0v0CZ+c6X3J1TQuycUGbxI1bThrkNKDYkbm4bMtVcbpbFjRuOzXF49B/wA8857jM/Jup6P3J1TzjoHh0H/PJurc96nVdH7k6hpGyx9oVJzcxaoAAAAAAAGpAAAAAAAHo9MuRis6GZpE6D/nmDSdxmpUXkEPvD2PriTg4QOiZKYTaiyFZxDF+kDXS4sMpaWNFtE7yiaWuDDOYSThGMRoFJx1PQ+5OoaQBKTrPzzUP1O9J3pO9J3pO9J3pO9J3pDVEpSlKUpSmI87mD1RQ1rtdIznSf8ANW+Eqp94S0DdXE8ImtI9UxRjZispiHDMVjbbYusILeKVgQ7EjjaXLDODGGKRmQutU7sH8+SCuzGIF7+iFFuRBEY0NTIWUxR9VKNZcs0tcwMF8efWIQwagtLpmIxb4zZjzn8B6H0iqX7MO8X6XhEzxX74Dzl8BCoPFbWp6P3J1DVMc3cw2w1HOBLlc4OMcBjgOc/xoPT1iRd1s5TGf9lxmVP6LUuZFLhlgCwjhDCQlNuFlgUCRI0MdcqnXoPF0ydB/wA1dpPkCDtL4RA6xAAzVZXMroDu0MYAbB5j3NkybfkAVk+k2TViqZxrWGV0zY8oFkg23HDKZs24h58Y+KltsXZGJHkNYQHGk8TSdxmqVc5bx8KpDAGPFLrJl+N4xz0OYPmwwOLyw/eh0PuTqGqp5Nsa7YYDzx+UYQAW02n8DgnKjn1JR0CuaNTTfAWHOWOs2DBfqYMBTgoijFaEA9sSs5eQqWY1AcYD1RhtcLL01J4dB/zSz25yw/c55ubWhlM/Gv8AYBVgZS02xfG61TuM1LmylVdpVb/6u2J2ZO3J2tO252XO0Z2jEk7QBg4mbqW4ftKiiBKqeGi4/khFW27waFbkxCtsqVKlSpUqVKlSpUqVK1C6Qd2Yh8aUAZtttPGlB0y3o8Rz5W734PPnFF7SJnYM7Dnac7Hna07MnZE7Yj/NTsvQ29pjCtVUeAabuM8uYUG0afH4Tho9Se/ll1pfB56DhSZq3qHTPoU+E4aPUnv5w06+Dz1jpm6x5r5Tho9Se/lV0zT5fJx1bpn0MAAfCcNHrT3g35N0w1HfA5wZcuXrTHVO8TrPjuGj1/u3HXwOegGk6ZqncZ5r4bho9ee/geRdM1PfM5updMNW7jNft1fwnDR6/wB2tMpj+6WsS8V6Dphqu+Bz8TzDuM1y6z4bho9ee/gav5jhCfaBUQONdQDGoTgRotVLwcmWsdleS75nN8DSXTNY7jPNfDcNHrz3gaH5frkEZLPa26Ypk1BKxpmZi45y2q2RWCqGmSmxtmH1WL3yObpuma13Gea+E4aPUnvo3ls9ycjBY8zKnap2qdqnap2qdqnap2qdqj/CnaJ2idonaJ2idoh/Iln6Y4/vMPPVV8DnDzTuM818Jw0epPfSvCXF8kKhGkiJFXb4umXxOekumGudxnmvlOGj1J769dMNaXweei6Ya93Gea+U4aPUnv5U0l1DfB56L5Z3Gab5P47ho9ee/iat1jqW+DzdBdM8g7jNJ8p8Nw0ev93iapdM0nUl8Hn4umeRdxnmvjuGj157+B5E0nVF8Hn4vmHcZpPig9tAWrK/G6nJK0a1Xx3DR689/A1S6Z5Bvg8/BdJBalAIfeYYZsL0CeSdxmp2ZNGMUMuwcGuNjtuUCieVfRw4y/q3uhgsOAmwhIXayPLKCEXFaDBEBItiGjtwEoeJsz9sAaU8BsQ9ZVJzca5RwUMpgNWW7waHT+O4aPX+7xNQ6ZqHUt8HnqFex0meWWMGGJ+pMLjjwZQVlY3Mw2TBCgVDXj+8qVrLZGNuFRt3A2DDY04S05qYLZ25y9ftIacPaH2g1nm9WpeNsFmvA2BU9Gmgtty56l3GadSpUDlG1gggggzA5y0bqbLlzmxqWIsqK2t91+YLyQLiIBgLaxzn3MVeEXU3ZG8pcFcVcqVKiYw4C6l6zhAPElT4Tho9Se8qVK1FSpUTW1Kh0t8HnKlRUA4MjDINwFLoc6FKmc6Km2dam0xWN5t4y1SKhsHFAEvM8CWgwsTjnFgKTIXlPcmxiy32dql226l3GalxZCqnszO0M7QzsTO1v7naX9zsL+52Z/c7Y/udkf3Ozv7nb39ztL+44HqAWPWYAk0fiHPwD5Bos8NEzjsjlABgvDw08Argam2CseESmnRfA1mcWWXOR+M5H4xBleMMJyPxnI/GF6bCsPFwsvwDGJmikVh1j/Yfudvf3D+O/udsf3O3P7nZn9zsL+52l/c7WzsTO0M7QzszDWAMtTdxnlwL8srGKra26HS+5Oqaro0x8ijuy32Gg3ljHbjVL9GEK+2rgfuFLYGCqDDMbiGyW27VZsJi8I2m4cEyLwVGzAzFB+8GFrMVr7ylFZmKxiKfTbd5avpP+aSAlJkx2+eW3wrHyruMz850vuTqmmZO1kEYIUzpvwGhMyWG5tiUgKWvmmMBnyZXMNlnq3BgjGOCYNT0spmbY5vGKCyawTMRLJiZMqrGYQRglYCF54sWMw1gC69fEUGBe1jsKffT6T/nnnPf/S+5OqaeOnvK5RLY/jJX8ZK/jJX8ZK/jJX8ZK/jJX8ZK/jJX8ZK/jJX8ZK/jJX8ZK/jJX8ZK/jJX8ZK/jIFZ4c9fg0+k/wCfQR5vpfcnVNME9GTGYRseSKhq62M/CcMjT6T/AJ51y3Keb6X3J1TcXSf8867lM/N9P7k6prKghCcrm0VnuqHlek/551z+gOl9ydU0CDdkn5PKKK0fdO5J3x44ELYnM8OdMuVXEYiT8nSOrKZVIM8senGGArRTXBkJgVERJxMJROz6xsOeMatk3hdgfxj9pWbZoZiF65QBzTVe2vwY/eLKT6869CsT1goj5PiLYHEPEmO+J3JHoQcl4zhm6Yv9ePQf8+gzzT9BlWRKLN0Bm2O0fJnBqODznf53id2ncptnFT4Uq27eLCXWMFNNYRVVkFwIoaqatm9YCAI6LyYADaK8WDhEwFuUr4hRL7aZRXxjBXpLZDPd4xbbcXx2quoncp3ad4nf4XbFWMONvGsPEARxLHnH/lB9Lv8Ayo+lXdg/Sa7uG/pFd4H0e7yv6NXeg/Ra72H6JXfBl9DuXnf/2gAMAwEAAgADAAAAEP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8Au+00000000000000000000000011/f8A/wD/AP8A/wD/AO/29mEU/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AMTffffffffffffffffffffffffffffTcf8A/wD/AP8A/wD/AP8AX21f/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/ezzzzDzzzzzzzzzzzzzzzzzzzzzzznXzzxzv/8A/wD/AP8A/vf/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP40MMMNAwGdeAGauUPcWajBiQeLD/XoeGMMMMIF/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AN9999999999999999999999999999999999999//wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A9999999999999999999999999999999999999999/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD7wQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQX/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD5TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTWf/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/APNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN//AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/APxTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTSf/8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8AX333333333333n31/H32wijDzf33m/3T3333333333333n//AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wC8EEEEEEEEE8888q090888889EEEEE30kMEEEEEEEEU8sEEF//AP8A/wD/AP8A/wDPPPPPPPPcEEEEEUUV3PPPOLnPMnHHHG33333XPPMMEEEEUkk13PO0EHvPPPPPPPP/AP8A/wD/AP8A/wD8EEEGewyxzX/X+pX/AP8A/wDUXm/hu4V//wDjDBBJBX9spcn/ACQQf/8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8AHHHGHGHGMFMsSNMoEEEEEEFHHEf/APtjCWx/TTz1tt/jxxx//wD/AP8A/wD/AP8APPPPPPPPf999999999999/ww99999999999vPP6CCT99999HPPf9999vPPPPPPPP/wD/AP8A/wD/AP8A/BBBBBBR/wD/AP8A/wCwAHCQQQQQQQRX/wD/ALGCCAf/AIQUf/8A8kEEEH//AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD0EEEEEFH/AP8A/wD+/wA88JBBBBFJBd//AP4VgAA/6QRX/wD/AJBBBBB//wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/BBBBBBZ/wD/AP8A/vww8BFBBBF3t/8A/wCkFYIILsEFX/8A/hBBBBB//wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/BBBBBBBBBBBBXAApBQDBBBB1/8A/VwXggggQRf/AP8AhBBBBBB//wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wDffffffffffffwAPffffffff8A/tX214IJb3n/AP8A+/fffffff/8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AO/faX//AP8A/wD/AP8A/vAA8v8AfffaX/8A/f3nf4IIf3//AP7d9999999//wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/BBz/wC//wD/AP8A/wD+sABykEEEHf8A/vBBF/8AgglgX/8AvUUEkkEEEH//AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD8EFHvO7CgxnPXfDDDMEEEXP8A7hBBBRyCCX75/wCRNFKDwQQQf/8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AOwQQQYUUccUc7wo+wQQQQIzwdQxQQQUMUsAY4YYYYYQQQQQf/8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AL/ffffffffffffaPfffW08oksgssU/ffV/ffffffffffffeX/8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP5TTTTTTTTTTTTSLTTXTTTTTTTTTfTTTRzTTTTTTTTTTTTWf/8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP28cccccccccccYOcc8fecNNONOcfcc8U8ccccccccccccb/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/APBBBBBBBBBBBBRBBThBBBBhAhhRBRzBBBBBBBBBBBBBBB//AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A+0EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEF/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A+8EEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEF/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AOccccccccccccccccccccccccccccccccccccccdf8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A33333333333333333333333333333333333333//AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8A/wD+800000000000000000000000000000000000l/8A/wD/AP8A/wD/AP8A/wD/AP8A/8QAKBEAAQIGAQQBBQEAAAAAAAAAAQAREDAxUHGhICFAYbGAUWBwkfDR/9oACAEDAQE/EPymJDQMg8z8rWTJpLJk0CCK26g9lqPZt1B7L+jybM6dOn40Hsv6PJ5unTp7GVCbqvO/a879oqJP1nACE/ULwkTVBGBAC/J06eybEauZ2+I1M2zYjVzO3xGpm2bEauZ2+I1c2zYjVzO3xGpm2bEauZ2+I1M2zYjVzO3xGpm2bEauZ2+I1M2zYjVzO3xGpmyOnTp06MdiNXM7fEameLwdOnsYthdMz0rwUHZYTiECKrzUMafUf6noCLbQey1Hs26g9lqPZt1B5smTJk3PUez9gEmOafFj/8QAIxEAAgIBBAIDAQEAAAAAAAAAABEBMRAhMFBxIGFAQVGAcP/aAAgBAgEBPxD/ABNPk3w8yyyTXQ1whqBakSRRH0LTGrI+mfiHR+s9jsmybFMY/P6uMY8ORyMcjIwxjw+OsIwt1Yt24V7NhG7HhbtwsxghYRh4uI2Ndm3bxmBYLCI+YhCEIQiSIKT3HuJzOr93rT3HuJJ1ThCEIQhC4OrNne9b1x/Vmzvet64/qzZ3vW9cf1Zs72F5W9cf1Zs78EIQhCF4W9cf1Zs73reuP6s2d71vXD72Ks2d71vWxv58wIQhEYZVmzvet68d4kQsi+YhCEIQjRYECJ0PQRqh5MeX4TD0k9RJmXH2SziMIQhCELhazvPwt246s/Ct246s5fg8j8jxbtyKELZQhYiIj+WP/8QAKxAAAgIBAgQEBwEBAAAAAAAAAAERITFBgSBRYfAQMHHxQFCRobHB0WDh/9oACAEBAAE/ENzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3NxMxIiSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSRoxsjc3Nzc3Nzc3Nzc3Nzc3Nzc3Nzc3Hh5qjXxnhk3EpcGOwqRubm5v8kSbEqz83avA01/fg/SD7+TJSrL8fJ0m8C5zb50+Uaaz8F0Bz8JJJ8JJJEp9iG20v5Ll4Fz/QhfPXDHy/T4Jvo5GAcPqNRoUUajq3COS3M5c/JVziSWF/gWpQ+UfwKxG/qeh9DoL6Df8AwNzr9/kqZ/0SLTfyGISy9B63mVa6NBPpPqN/4WKKZaSbSLWHPT5hyVihMNw43bEUkdTUYv16aeU0em42/r5xqsjym2hvnBklARTpSNRvnptYVJ8LNYZUEOcZBQ6qUth5IPDoNBxS/wAik5FtMoxLaW8jjzl2qzho5K9JmS24hGVDclqkrRpoRl9MUlRJTk16lqNXJyYDcPMYXWWHGqGrrSjEtqY5sbdYTghxFyV5uZ1ZFwAeTSlDtKlPFoTBSyPn8MxA/VQQUMpQ2pjI1VVNGLmlp6o+4ktCo0LCjKueow3FR1LlxaZGplKbE6k3D6OCWwQgreRpIftWyobRNtHzcRuLGijXTdpJWbzltyMi6NElGikpiWOrL3PGTktMiZ5o5qJicJp/oPiQSp5kpypbTctOEqsdY/DJBNxMJpwpTw4hoYekkRKRzDaaHpqOg3IRWIHDmVWqbdSSiYX4FkjyTGkpNw221eiU0hyBqoxeEll6zCp3IpbVBfnLdLRXzIhMKYXt0Tm3ea0KS1a05EnClttkEaXOCakKlKd6tTiCY2mHMURlJ1D0d8xIKrUhcO2uHsSdjU02nJJW7dKh85lBuagcOpcrcwlMDldaKaBSSfqXLA2I5qGaIROyGW2zjtOjtiXKxHUcmNpKVoZcNJLE2wMrTVGVJwIXNqIySkZgZoO1mETEWe2VuEWiMRmaEiw9atCklEwvqyUxk2LRbSNK6pkupblo4W6GmsUoyV+MuiimFe4iew1olkqShxq4nl5nJ+nzVWyFHU6nU6nU6nU6nU6iiVLaXoKn4z6Vdto59MNcmMrbaqmaJto2lLRikLA+TpZteriElmRI3gQSbTO36iSsx1alGYaT2FGGa1920h4WicNYZHPiGXFKnLWmU3VZQzTVdV0qrVU11Q6yBFn6banEJTCnq9SGifO41LGYaUxoI2s0PtzmEQcaTHUlsHdq6IpttZWU4GYESmaPbh3CQoxmSTI5QkddBeAyKIrasefEYlNTtNDXoMqsHFJ2pSSZ8HCWvokqTDvEEScDTRPDRovkPJKZsJZnoYTOnhSoSby1pKGBK6Ta01FiOXQqlaiZIyjBAJIlchWWP2iaJXEtuJTbTU2nQ3PVxmk1KTtuG4SWsyIQwTRMo9Ul9hbWiBQ4F9BKUFQRw7bNYlfkmaxkCQm0rTSSWIcSmJ3Tc4eUmHpKXq4JxQbrNNMpiUIYUhw2BmmU6+rmxiaQogTNJ0klb21JAKSkmlTosJLCJ0Zp7Ww1k0nhav0Y3lRnk4ZvOi5qaVEwGZUw04dqmONAbJrcNuFKlTalOh7j7RaM5X6H1QxURTJ6JK1sOp1lZXySetKW5iCZ4ls1C5iUk3SasTn9LMjge7E5vL1sqkq7ZJUxSNYrN1Um20qm1BGN3ycQNVKTnYpPaY+LSScrnJKJGoV6GJpTi2sN6ytR3CuivMjh0lCnXTUmc3qMzFP4R1Op1Op1Op1Op1Op1OpJfzPLgg83D8NI08Z6/Ea5+C3j4GRGH8T1Op1Op1Op1Op1Op1Op1Op1Op1Op1Op1Op1EpZB/j4A6Z1Op1Op1Op1Op1Op1Op1Op1Op1Op1Op1Op1+IgX+Rk0+Xa3+TXVfLEllFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFCQ/lWolCNjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2ElRBrj5StyIQhCEIQhCEIQhCEIQhCEIQhCEIQhCEIQhCEIQhCEIQhCEIQhCEIQhCEIQhCEIQhCEIQhCEIQuv1+UK3Aqr/LtTRhx8nW5/wAyuvwllllllllllllllllllmolC/zLUo1LLLLLLLLLLLLLLLLLL+DSf82SH8lXL/zfP8HBBBBBBBBBBBBBBBBBAnyAru1kkpbY1f645BfGxOk2qXaleqY2poklkLmWySVCgiN6hdBKbSfR3Q9GVppRpNsmEoa11JQS2I2XkT0TEJMs0pq5QV5rcRnIxk21TKHiLopFqklMiTfNjQ7IRygrRsxfoKyizopcOGhIAUOJMJ0fkJkJG26iB5eYhpqGn8gSRBBBBBBBBBBBBBBBBBHwWvxkxj4duFL+wx6GmQ+CQ6x5VZnlTzhflxaiW3f9xp7H7jR2/wBxr/R/cazXtLgnn0XggSt5zBpK9IegOoNZUSk3q1TS0lRHArYtmkVM8mRGUn7VSx46RCmwjXIqy4qhj1TWRwJUibZqfL90j++mjctZerKgy0KnsKR+knSWog5oSptRLzOtzYmVrrFTn5J0uiMadDjFjVHRJlHTxtKqCX+jE81P7P7iZ2/3E3ufuMHukFtNWnkZ5KV8FlH/AF8WXK0Gk+U/54Qd458FzMIZ/D+aIFMcqbUV5z96phaatMToB4JNYSq/KRG1pEpaWrSH9olL+qvpp/l1Ce4Nzc3Nzc3NzfwYc97hubm5ubm5ubm5ubm5ubm5uKxKK8p7iTc3Nx7ifhQGhG5ubicP4msssssssssssssssssyfwTQiyyyyyyyy/Bh3LmWWWWWTgmtt4Tmx6DJc/NbHuo91Huo91Huo91Huo91HuoWU/fHuI9xHuI9xHuI9xHuI9xFozt7LU/6jLL8M0Zllll+DSiXwUJhDcsssssfTizLLLLLLLLLLLLLLLLL+C1+S0Io3RyUubEbK3lHqUho1OlQZ1wum9GzTBJzJR4haiEm7bhMeM6aajZW4TFqdeQh5jghat9CmaOf/ISKbRObUeI5ifJSpL+jI8OVmkhryiHcOfFyz60Tkx8h6GvPQHan7O1P2dqfs7U/Z2p+ztT9nan7O1P2NP8Aa/p7gPcB7gPcB7gPcB7gPcB7gGwZGmjTiU59Bqt+WzL4mjzGCLOp0GJQ230SYoz2if28JT6NLBjiylqvC0J1YNuZKLM8jQfqQhLRujqD6pynmQBjse75VqSZW1KX4EgXTTLDnWRJzJdonWMcE9RY4c18j1G5ubm5ubm5uP8AbRzyXZJt4idRYz3rs7YQ6U5WB0exPyaDKa04SaTsh+16E6c1QTbhSNI8g0lpbJtJ4J6qRev8tO0VLq1qiQchMyIXOpcO6MGlVk1WqbDL6ac/YGo5+gw6djC7CbTSlKVuUMzhiWCQJVp615TDuHPynR2mUCILAqcnfMqWm1n/AKMLjxzSXI00mhOCWxcEsxKhxqUNc7fQzaoI1kqE9UWQteZOG2EklJKsa3m0nPifcWteCGrUTldRAswgWYuF+BEjEgwOJpUurI/si7cuFAmz2QnuDuNETYp+pubj6ca6/TwA3Nzc3Nzc3Nzc3NEl/wCvMSbwiRDZlii5DNMlRMxuOi9JnYtOrpO+QqhSFoNbrRZ5RliSDDEKOQ03OFOsChL9EFpXy03EgkRdkRJmTalDEsjZrXrNulnkPwUVqxLzOG2xqmJms7YNiw5iEQKRnjmMA03Lqr8Ulm5ubm5uZr5bYSzb5tjZTaPUlzMsUUxUJ2ycnN4qhM1i3JTMu+pOn2JfUkpS55yI8p9XwYrJlpKuanl+hEAIrdck1XCQ7hz8pAHJ4cp1foJLUimsatS5jRTgvM6JY+upM7NFY4bUWxJ2pLm646ROBRdMYWqa2Iu9TRNcy5rQRgtK4uUa7UJdOiaYHEQl6CTY2LCczY+2SSJQmYaf5GC+NhMieG/ToJNvOFliBz8CyjrpCfBuDXiSX5AiByMV6Bc20Q9Ak9yfKmK4E20ptPoNtpbbb5kvmyXOXYjpaE5GuJS3cZEpTLomMergl9aJczLnnImwbU8nnxy8CUKOLT8j1+S86TElzNJ6nto9ji/4U9rntrhYSWqfBgoRdlCyaf1EHmL0zMS1WH2UeotSfFttpN2ewCdN8OmpUO+8jEza24Hsgg3OylomR6kepHqR6kepHqR6kepHqR6kepHqR6kepHqJRxyPiQ/5MHUkePpj2MIkqww3zg9jHsYW3syYUy14y4pZcmJjeG07N1OE9J/UfFwoIRVo/BpjH8EG9pntU9jDCIqF9Ja+GtHHp+R6/h2VcqMbofh2rk4e88vw0SjjW/tT4vsP5eKbTlNprqMqLMkb6t+Q0LjSWRXHo+Cggggggggggggggggg1fFdi5OHsPJ8K3CHZBBBBAkuDvuj4vsP5eY0sggggjwSFHkIQQQQQQQQQQQQQQQQR8Fm/iu5cnD2nk+FkfFqJCO66Pii9F+Xlvpxrr5OS+R5FllllllllllljcLB6Puej7no+56Puej7no+56Puej7no+56Puej7no+5buqcLQ7tgcgWWWWWWWWWWWWWWWWWWNCjjmss7ro+L7N+RRZDmQ5kOfhZZZY3CM8SS/PhZZZZZZZZp+R6vOSH5ncOTh7pyGGJyvgW4G5fElLgxXh23R8X2b8uDW4ml8aQvK0/I9fnNSjXy+0choaGhod15PBofwLzXGkLx7Do+L7V4iUsiFwtFcet8u5vz258t2rk4e6cnglLjy2hKk4aqCzWREWSU0r9V4Q+Xg0Ljkc8HYdHxfZvy8UhcLcIdviSlx5mn5Hr87S8x+40EkkknceTwSF5mGGgqbQI6JtVPIUoLAiSQ2k2k3VdBp1LSJEUnCwLJMjFFpusjcueJKWJRwdh0fF9q8BZc8UjjjSF5mn4KSSSSSSSSSSSSSSSSTN+a8YIbev0IfJkPkyHyZD5Mh8mQ+TIfJkPkyHyZD5Mh8mdo5OHsPIWWuBWQkldbVNsqtAkR1P0njayxujJo+cnBUnTpz6moOFxNClYoJskkkkkku9p2pJXGsDI9aUs9Hya4Ow6Pi+2ArZhcLwiSSSSSRJvzdJJJJJJJJJJJJJJJJJPyz2Lk4e08nCyj2Srf2QM3DDH/p7l/p7l/p7l/p7l/p7l/p7l/p7l/p7l/p7l/oiv3f6e8f6e+f6e+f6e+f6e+f6e+f6M/wBP9E4kmt9f9EasmFwunAGp7U+L7N+QkKeF0Ny54kpZEebp+e+xcnD2nk4cXP0J/wCwpJfLyZ+g3L4tRKEPLMSmnhj27y2ctvxaEdl0fEs+i/Li0uOBT52n5Hr+K7lycPaeTz9Lj1teF4G5Z2XR8X2H8uFoXHM/P0/I838V3Lk4ew8vnNwjXiSXxaXh23R8X2H8uDQaXxZEoXn6fkeviY0v4PuHJw9x5PFG35XUaXxaiULhaEa+HbdHxfYeA0uNan4DT8j18T6fCdo5OHunJ4aiQvK0uNdeH8DS/Hsuj4vsP5eLQvwa8SS/gdPyPXwukTfwncOTh7DyeC3PlNwjLfEkvieo4Oy6Pi+w/l4tL4lkShR8DmvkeskkknwSH4oDYmwYSSKasqLWUlRLk/oQ/TYh8vsQ5iL9DYlyf0IfaNiGna+3H3Dk4e48ng0MkkkkkkkkkkfGkL8kkkkkjUqDD8e26Pi+w/kSaX14kjq1VoltlryLkkUXWZDTj9kNO1fVFzgh8n9DYsh8mXMRsJN4RJJJJJJJJJp+CssssssssssssssssszfE1K8LNaKeDtT1cT1EbTycVzniCV1kboE/o1mTtzCpYjp6SlUSuMLXRE7t81dpso04/BkgAqlB4tJJzSrBGSEzmNwOhdU11J9Ic/mpcnl5nI+HQPaCTSSTaOUKWJiLiPbaUdgcHyNFO2sre1DaabWrLLLLLLO4chJJJJ3TkLLH08hoossssssXXyEqSyztuj4vsP5DcIZZZZZYj8ktnaRq2g7rcVgxVKmeSbKOY1ECyXYtUhZu+eolNogmSTVTKbiVNLQWgqYGhByleosvUXX9RJE5koudOVi0ZPsm3gw0cTUPkPmco6W4KYpC6BvljClmrqMzJLRORapXcNa5k9FChzYzxri2CNRSZpK0Q8Pytllllllllllllllll/Ba+No+ZHqR6mAlDrX0TcCz+REJOvMbge5tPRPVpCnWHQXCSBQ3Jv7GfbEv0G8GHBiLU68yRWiuGI+ccxhUhJzSiwlygTkTUto9WR6kepHqRVZTBecCsgMlOnZ+VoR6nauThWe5oR6kepHm/Ig3qR6kepCpU+KUuBeTHqR6ik2/Y+L7D+Q5cyPUSefdK315LUdzqogc2jXwQirvWfURYUsv6jsnXMNNzSaxl6CQmqmXJdXkTSBpEtCdssVhMDpesMb0c2GUNzfMm21NJejkflT9OcjsAkM+XrA2YxtvL+LwQQQQQQQQQQQQQQQQZ+SuU0JtLqoeTvr9nY37Iu++52N+/Fp+h8PVkBkjx9mfRDk1hNltyQZJCCxyTMjb9UVfguBVzZhUsM95f0VZpdzp07WX0IHB6V+fqe8v6P0Wm506c6vyEpcLPIaZX00uRjENNU01wpD8EheZBPhCUe9f6e9f6QsdEqONJ6nvX+nvX+mIjKWFGf74viYXuTMNpquk1Q2OxOtllNDM8JPmb+kZ8N4tGfbu2v2djfsm777nYX7O+v2IbihE0n1vuvJzIIIIIIIIIIIIIIIII+Cz+Hst9CJpTHp5ltt23woO8c/K7JzHLmV7Uyqt9xeeKRJG8t6QQV+Jk2TtB88DD1mhZxwlj0Clk6xFlym28uCS9daRIwTwpwTDOZN71buvYYd0ubKknGLVijUJk+zn/g4p1oy21LbGMIgpCmXScQlw/0QuVNnIOYE+2ZSZOG1H3+BwZgeTQ4afND2HS7Lbr4aAsfCPfwUEEEEEEEEEEEEEEEEGD41B3jnxsEuwhbYwdhwk8tvB+RCarUgdplzLoKJFIpRL9ZFPOy1fMElJqdxuyQ+KGlUtYY3aWrTtXYSHQnSWZ5mWOwoWpmFywOYSQY1MMX+UkiSLtOitjQoSPRLqIfKOLWYcoc1O1FVEUnxhdyEpIS9SMC4atJzT5fJsCCCCCCCCCCCCCCCCCPl6DvHPjRG8CcxTXpv3GmcvWfg3/8A/wD/AP8A/wD/AP8A/wD/AP8A/wD/AP8AlBKUVJclH5fJMH8lwLLLLLLLLLLLLLLLLLLLLLLLLLL8EHeOZZZZZZYyezKGWNAaIU89/wBlllllllllllllllllkrpMnBT6McHrEIQnkkWWWWWX4YWWWWWWWWWWWWWWWWWWWWWWWWWWWWU+SsY+MQd45/P8HqPkrR8YAd45+Y3qlcl8JWY69S36MJEzHL/GsfMsGn5MTlSZMmTJkyZMmTJkyZMmTJkyZMmTJkyZ8EHeOZkyZMrI2luhha9fyoibeFEjsb9HbX6PcP8ADou7+FgYiWr8mRZhkymHKuqyuqFGeET5I+rLBYX3s7f6Ybbko1EPpmYZHUp31Ffq9IeyTcrcSQuck7r9Gk3pCRGIbKhvPNpIdYEZu2Elrr5IZvORVuFpR3XKFAoI6jZNLl3C8hCIkklJLrMmTqBQtEv9n8PcP8F31+Dsb9COKm4hOTjRnOVIc9E569DJnwQyZMmTJkyZMmTJkyZMmTJkyZMmTJkyZMjcKfhIIIIIIIIIIIIIIIIIIIH0+KmaFKRWmnXoyFCVt8CZbxTSVfo7NpQ2ilY25A35M25M2ZAlJ52KnwSESgyNJ6NrEjRnrnOk2U40ZNgWUcuYWgqlprG1WFa168iM+kOlzlyfVchF2hpDwvKb1kSVyFjSZhThf0jyejrJynAqcp05GC7FPorUklS9BKVzgrJHznMjGsbLbbt+N8jcipEjAEnCwl4Mk4AqnQRoSl828CZ5Q2yUPoaN9rwXRScDVde8fGPoQQQQQQQQQQQQQQQQQQR8InDMpf5fCY3L+UPp9P8ALvp8pwJyp/yrcKTX5U0P/KtL+WaD/wAnAoT+W6kD/IwGvy5UxpO8HeDvB3g7wd4O8HeDvB3g7wd4O8HeDvB3g7wd4O8HeDvB3g7wd4O8HeDvB3g7wd4O8HeDvB3g7wd4O8HeDvB3g7wd4O8HeDvB3g7wd4O8HeDvB3g7wd4O8HeDvB3g7wd4O8HeDvB3g7wd4O8HeDvB3g7wd4O8HeDvB3g7wd4Ghfodv5gnHqKS/wAbAhuc/MsMkX6/xcCM/NNTmfX/ABPI+cYP8Pk+N//Z)

Одним из наиболее важных показателей для анализа поведения биржи явдяется минимальная цена акции за день. Этот показатель рассчитывается на различных периодах времени наравне с максимальной ценой акции за период, цене на начало и конец рассматриваемого периода, а также объёмом продаж. Все вместе эти показатели образуют знакомый многим инструмент - японские свечи.
Предположим, что аналитик разработал магический алгоритм, предсказывающий поведение акции. Результатом работы алгоритма является участок функции, который отражает движение котировок на период следующей "свечи":

$y=\sin(x) - \ln(x^2) - 1$

По данному предсказанию определите момент времени (в условных единицах), в который вы могли бы совершить покупку акций по минимальной цене.
"""

mpl.style.use(['ggplot'])

f = lambda x_: np.sin(x_) - np.log(x_**2) - 1
x = np.linspace(-30, 30, 10**4)
y = f(x)

plt.title("$f(x) = \\sin(x) - \\ln(x^2) - 1$", fontsize=15)
plt.plot(x, y, color='xkcd:deep purple')
plt.xlabel("x")
plt.ylabel("f(x)")
plt.grid(True)
plt.show()

"""Функцию $f(x)$ называют **унимодальной** на отрезке $[a,b]$, если существует такая точка $x_* \in [a,b]$, что функция $f(x)$ в полуинтервале $[a,x_*)$ убывает, а в полуинтервале $(x_*,b]$ возрастает


**Достаточное условие унимодальности:**

если функция $y=f(x)$ дважды дифференцируема на отрезке $[a,b]$ и $f^{\prime\prime}>0$ в любой точке этого отрезка, то данная функция является унимодальной на отрезке $[a,b]$

**Необходимое условие унимодальности:**

если первая производная функции $f^{\prime}$ неубывает на отрезке $[a,b]$, то функция $y=f(x)$ является унимодальной на отрезке $[a,b]$

Для того, чтобы определить интервал, на котором исходная функция является унимодальной, найдём точки перегиба. Для этого вычислим, в каких точках вторая производная функции равна $0$:

Проверим НУ унимодальности на интервале $[0,7.587]$. Для этого также найдём точки перегиба и убедимся, что функция на рассматриваемом интервале неубывает.

"""

f_prime = lambda x_: np.cos(x_) - 2 / x_
x = np.linspace(-30, 30, 10**2)
y_prime = f_prime(x)

plt.title("$f^{\prime}(x) = \\cos(x) - \\frac{2}{x}$", fontsize=15)
plt.plot(x, y_prime, color='xkcd:deep purple')
plt.xlabel("x")
plt.ylabel("$f^{\prime}(x)$")
plt.grid(True)
plt.show()

"""Видим, что для интервала $[0,7.587]$ необходимое условие унимодальности не выполняется: точка $(6.333, 0.683)$ является точкой перегиба.

$5.114<6.333<7.587$, поэтому интервалом, на котором исходная функция унимодальна, будет полуинтервал $(0, 6.333]$, т.к. функция не определена в нуле

## Алгоритмы одномерной минимизации функции без производной

### Метод дихотомии

Данный итеративный метод направлен на сужение интервала неопределенности $[a_i, b_i]$.
пусть $\varepsilon$ - желаемая точность, с которой мы хотим найти минимум, тогда $\delta < \frac{\varepsilon}{2}$ - величина отступа от середины $\frac{a_i + b_i}{2}$

Во время каждой итерации значение функции вычисляется два раза: $f(x_1)$ и $f(x_2)$, где $x_1=\frac{a_i + b_i}{2}-\delta$, $x_2=\frac{a_i + b_i}{2}+\delta$

т.к. $|a_{i+1}b_{i+1}| \approx \frac{|a_ib_i|}{2}$, и после выполнения $n$ итераций $|a_{n}b_{n}| \approx \frac{|a_0b_0|}{2^n}$ то для достижения точности $\varepsilon$ потребуется $\frac{\ln\big(\frac{b_0-a_0}{\varepsilon}\big)}{\ln(2)}$ итераций
"""

def dichotomy(func, a, b, eps, max_iter, drawing = False):
    if not eps:
        eps = (b - a) / 1000

    intervals = pt.PrettyTable()
    intervals.field_names = ["iteration", "a", "b", "length"]
    intervals.add_row([0, a, b, abs(b - a)])

    if drawing:
      x__ = np.linspace(a, b, int((b - a) / eps))
      y__ = func(x__)

      plt.plot(x__, y__, color='xkcd:deep purple', linewidth=2, label="$f(x)$")
      plt.xlabel("x")
      plt.ylabel("f(x)")
      plt.grid(True)

    delta = eps / 2
    ai, bi = a, b

    if drawing:
      plt.axvline(x=ai, color='xkcd:sage', ls='--', label="$a_i$")
      plt.axvline(x=bi, color='xkcd:light grey green', ls='--', label="$b_i$")
      plt.plot([ai, bi],[max(func(ai), func(bi)), max(func(ai), func(bi))],
               color='xkcd:heather', label="$[a_i, b_i]$")

    i = 0
    while abs(bi - ai) > eps:
        mid = (ai + bi) / 2
        x1, x2 = mid - delta, mid + delta
        y1, y2 = func(x1), func(x2)

        if y1 < y2:
            bi = mid
        elif y1 > y2:
            ai = mid
        else:
            ai, bi = x1, x2
        i += 1

        if i == max_iter: break

        intervals.add_row([i, ai, bi, abs(bi - ai)])

        if drawing:
          plt.plot([ai, bi],[max(func(ai), func(bi)), max(func(ai), func(bi))],
                   color='xkcd:heather')

          plt.axvline(x=ai, color='xkcd:sage', ls='--')
          plt.axvline(x=bi, color='xkcd:light grey green', ls='--')

    if drawing:
      plt.legend()
      plt.show()

      print(intervals)

    return {'x min': (ai + bi) / 2,
            'y min': func((ai + bi) / 2),
            'iterations count': i,
            'intervals': intervals,
            'computations': 2 * i}

dichotomy(f, 0.1, 6.333, 0.005, 500, True)

"""### Метод золотого сечения

Точки $x_1, \: x_2$ находятся симметрично относительно середины отрезка $[a_0, b_0]$ и делят его в пропорции золотого сечения, когда длина всего отрезка относится к длине большей его части так же, как длина большей части относится к длине меньшей части:

$\frac{b_0-a_0}{b_0-x_1} = \frac{b_0-x_1}{x_1-a_0}$

Отсюда

$x_1=a_i+\frac{\sqrt{5}-1}{2}(b_i-a_i)=a_i+0.381966011 \cdot(b_i-a_i)$

Аналогично для второй точки

За одну итерацию интервал неопределённости уменьшается в $\frac{\sqrt{5}+1}{2}=1.618..$ раз, однако на следующей итерации мы будем вычислять функцию только один раз, так как по свойству золотого сечения $\frac{x_2-x_1}{b-x_1}=0.381..$ и $\frac{b-x_2}{b-x_1}=0.618..$

Для достижения точности $\varepsilon$ потребуется $n \geq \frac{\ln\big(\frac{b_0-a_0}{\varepsilon}\big)}{\ln\big(\frac{\sqrt{5}-1}{2}\big)}$
"""

def golden_ratio(func, a, b, eps, max_iter, drawing = False):
    d = abs(b - a)

    if not eps:
        eps = d / 1000

    intervals = pt.PrettyTable()
    intervals.field_names = ["iteration", "a", "b", "length"]


    if drawing:
      x__ = np.linspace(a, b, int((b - a) / eps))
      y__ = func(x__)

      plt.plot(x__, y__, color='xkcd:deep purple', linewidth=2, label="$f(x)$")
      plt.xlabel("x")
      plt.ylabel("f(x)")
      plt.grid(True)

    K = (3 - math.sqrt(5)) / 2

    x1, x2 = a + K * d, b - K * d
    y1, y2 = func(x1), func(x2)

    ai, bi = a, b
    di = d

    intervals.add_row([0, ai, bi, di])

    if drawing:
      plt.axvline(x=ai, color='xkcd:sage', ls='--', label="$a_i$")
      plt.axvline(x=bi, color='xkcd:light grey green', ls='--', label="$b_i$")
      plt.plot([ai, bi],[max(func(ai), func(bi)), max(func(ai), func(bi))],
               color='xkcd:heather', label="$[a_i, b_i]$")

    i = 0
    while (bi - ai) >= eps:
        if y2 > y1:
            bi = x2
            x2 = x1
            x1 = ai + K * (bi - ai)
            y2 = y1
            y1 = func(x1)
        else:
            ai = x1
            x1 = x2
            x2 = bi - K * (bi - ai)
            y1 = y2
            y2 = func(x2)

        i += 1

        if i == max_iter: break

        intervals.add_row([i, ai, bi, (bi - ai)])

        if drawing:
          plt.plot([ai, bi],[max(func(ai), func(bi)), max(func(ai), func(bi))],
                   color='xkcd:heather')

          plt.axvline(x=ai, color='xkcd:sage', ls='--')
          plt.axvline(x=bi, color='xkcd:light grey green', ls='--')

    if drawing:
      plt.legend()
      plt.show()
      print(intervals)

    return {'x min': (ai + bi) / 2, 'y min': func((ai + bi) / 2),
            'iterations count': i,
            'intervals': intervals,
            'computations': i + 2} # two computations for i = 0

golden_ratio(f, 0.1, 6.333, 0.00001, 500, True)

"""По сравнению с методом дихотомии, метод золотого сечения позволяет вычислить значение целевой функции только 1 раз за итерацию (это важно, в случае, если вычисление трудозатратно), однако данный метод сходится медленнее

### Метод Фиббоначи

>
Это улучшение реализации поиска с помощью золотого сечения, служащего для нахождения экстремума функции.
>
Подобно методу золотого сечения, он требует двух вычислений функции на первой итерации, а на каждой последующей только по одному. Однако этот метод отличается от метода золотого сечения тем, что коэффициент сокращения интервала неопределенности меняется от итерации к итерации.
>
Предположим, нам нужно определить минимум как можно точнее, т.е. с наименьшим интервалом неопределенности, но при этом можно произвести только $n$ вычислений функции.

Пусть у нас есть интервал неопределенности $(x_1,x_3)$, и нам известно значение функции $f(x_2)$, $x_2 \in (x_1, x_3)$

Если можно вычислить функцию всего один раз в точке $x_4$, то где следует ее поместить, чтобы получить минимально возможный интервал неопределенности? Заранее нам не известно, как ведет себя функция, и реализуется одна из двух ситуаций: $x_4 \in (x_1,x_2)$ или $x_4 \in (x_2,x_3)$

Т.е. неизвестно, какая из ситуаций будет иметь место, выберем $x_4$ таким образом, чтобы минимизировать максимальную из длин
- $\min{\{\max{(x_3-x_4),(x_2-x_1)}\}}$


Достигнуть этого можно, сделав эти длины равными, т.е.

- $(x_3-x_4)=(x_2-x_1)$


Для этого нужно поместить $x_4$ внутрь интервала $(x_1, x_2)$ симметрично относительно точки $x_2$.
Если окажется, что можно выполнить еще одно вычисление функции, то следует применить описанную процедуру к новому интервалу неопределенности.
Стратегия ясна: нужно поместить следующую точку внутрь интервала симметрично уже находящейся там точки.
На $n$-ом вычислении $n$-ю точку стоит поместить симметрично по отношению к $(n-1)$-й точке. Чтобы получить наибольшее уменьшение интервала на данном этапе, следует разделить пополам предыдущий интервал

Обозначим за $\epsilon$ минимальную длину интервала неопределенности. Тогда
- $L_{n-1}=2L_n-\epsilon$
- $L_{n-2}=L_{n-1}+L_n$

Числа Фибоначчи определяются соотношениями:
- $F_{n+1}=F_{n+1}+F_n$
- $n=1,2,...,$
- $F_1=F_2 \;\; (=1)$
"""

def get_fib_by_number(n):
  fibs = (1, 1)
  if n < 2:
    return fibs[n]

  for i in range(2, n):
    fibs = fibs[1], fibs[0] + fibs[1]

  return fibs[1]

def get_number_by_fib(fib):
  if fib <= 1:
    return 2

  i = 2
  fibs = (1, 1)

  while True:
    fibs = fibs[1], fibs[0] + fibs[1]
    i += 1
    if fibs[1] >= fib:
      return i

"""На начальном интервале вычисляются точки
- $x_1 = a_0+\frac{F_n}{F_{n+2}}(b_0-a_0)$
- $x_2 = a_0+\frac{F_{n+1}}{F_{n+2}}(b_0-a_0)$


где $n$ выбирается исходя из точности и начальной длины интервала.
"""

def fibonacci_method(func, a, b, eps, max_iter, drawing = False):

    fib_iters = (b - a) / eps
    n = get_number_by_fib(fib_iters) - 2

    x1 = a + get_fib_by_number(n) / get_fib_by_number(n + 2) * (b - a)
    x2 = a + get_fib_by_number(n + 1) / get_fib_by_number(n + 2) * (b - a)
    y1 = func(x1)
    y2 = func(x2)

    ai, bi = a, b

    intervals = pt.PrettyTable()
    intervals.field_names = ["iteration", "a", "b", "length"]
    intervals.add_row([0, ai, bi, bi - ai])
    intervals.add_row([1, ai, bi, bi - ai])

    if drawing:
      x__ = np.linspace(a, b, int((b - a) / eps))
      y__ = func(x__)

      plt.plot(x__, y__, color='xkcd:deep purple', linewidth=2, label="$f(x)$")
      plt.xlabel("x")
      plt.ylabel("f(x)")
      plt.grid(True)

    for k in range(2, n + 3):
        if y1 > y2:
            ai = x1
            x1, y1 = x2, y2
            x2 = ai + get_fib_by_number(n - k + 2) / get_fib_by_number(n - k + 3) * (bi - ai)
            y2 = func(x2)
        else:
            bi = x2
            x2, y2 = x1, y1
            x1 = ai + get_fib_by_number(n - k + 1) / get_fib_by_number(n - k + 3) * (bi - ai)
            y1 = func(x1)

        if drawing:
          plt.plot([ai, bi],[max(func(ai), func(bi)), max(func(ai), func(bi))],
                   color='xkcd:heather')

          plt.axvline(x=ai, color='xkcd:sage', ls='--')
          plt.axvline(x=bi, color='xkcd:light grey green', ls='--')

        intervals.add_row([k, ai, bi, bi - ai])


    if drawing:
      plt.legend()
      plt.show()
      print(intervals)

    return {'x min': (ai + bi) / 2, 'y min': func((ai + bi) / 2),
            'iterations count': n,
            'intervals': intervals,
            'computations': n + 2} # two computations for i = 0

fibonacci_method(f, 0.1, 6.333, 0.00001, 500, True)

"""Метод Фиббоначи по своей сути является улучшением метода золотого сечения и позволяет определить, сколько итераций потребуется для нахождения минимума с заданной точностью

### Метод парабол

В методе парабол предлагается аппроксимировать оптимизируемую функцию $f(x)$ с помощью квадратичной функции
$p(x)=ax^2+bx+c$

Пусть имеются три точки $x_1 < x_2 < x_3$ такие, что интервал $[x_1, x_3]$ содержит точку минимума функции $f$. Тогда коэффициенты $a, \:b, \:c$ аппроксимирующей параболы могут быть найдены путём решения системы линейных уравнений:
$ax_i^2+bx_i+c=f_i=f(x_i), \; i=1, \: 2, \:3$

Минимум такой параболы равен
$u=-\frac{b}{2a}=x_2-\frac{(x_2-x_1)^2(f_2-f_3)-(x_2-x_3)^2(f_2-f_1)}{2[(x_2-x_1)(f_2-f_3)-(x_2-x_3)(f_2-f_1)]}$

Если $f_2<f_1$ и $f_2<f_3$, то точка $u$ гарантированно попадёт в интервал $[x_1, x_3]$. Таким образом, внутри интервала $[x_1, x_3]$ определены две точки $x_2$ и $u$, с помощью сравнения значений функции $f$ в которых можно сократить интервал поиска.
"""

def successive_parabolic_interpolation(f, a, b, epsilon, max_iter, drawing = False):
    x1, x3, x2 = a, b, (a + b) / 2

    f1 = f(x1)
    f2 = f(x2)
    f3 = f(x3)
    f_x = {x1: f1, x2: f2, x3: f3}

    counter = 3

    intervals = pt.PrettyTable()
    intervals.field_names = ["iteration", "a", "b", "length"]
    intervals.add_row([0, x1, x3, abs(x3 - x1)])

    if drawing:
        x__ = np.linspace(a, b, int((b - a) / epsilon))
        y__ = f(x__)

        plt.plot(x__, y__, color='xkcd:deep purple', linewidth=2, label="$f(x)$")
        plt.xlabel("x")
        plt.ylabel("f(x)")
        plt.grid(True)

        plt.axvline(x=x1, color='xkcd:sage', ls='--', label="$a_i$")
        plt.axvline(x=x3, color='xkcd:light grey green', ls='--', label="$b_i$")
        plt.plot([x1, x3], [max(f(x1), f(x3)), max(f(x1), f(x3))],
                 color='xkcd:heather', label="$[a_i, b_i]$")

    x2, x3, x1 = sorted([x1, x3, x2], key=lambda x: f_x[x])

    try:
        for i in range(1, max_iter):
            f1, f2, f3 = f_x[x1], f_x[x2], f_x[x3]
            p = (x2 - x1) ** 2 * (f2 - f3) - (x2 - x3) ** 2 * (f2 - f1)
            q = 2 * ((x2 - x1) * (f2 - f3) - (x2 - x3) * (f2 - f1))

            assert p != 0, 'Searching finished. Numerator is zero. code 2'
            assert q != 0, 'Searching finished. Denominator is zero. code 2'

            u = x2 - p / q

            if not a <= u <= b:
                print('Searching finished. Out of bounds. code 1')
                return {'x min': x2, 'y min': f2, 'iterations count': i,
                        'intervals': intervals, 'computations': counter}

            fu = f(u)
            f_x[u] = fu
            previous_xs = [x1, x2, x3]

            counter +=1

            if fu < f2:
                x1, f1 = x3, f3
                x3, f3 = x2, f2
                x2, f2 = u, fu

            elif fu < f3:
                x1, f1 = x3, f3
                x3, f3 = u, fu

            elif fu < f1:
                x1, f1 = u, fu

            intervals.add_row([i, min(x1, x3), max(x1, x3), abs(x3 - x1)])

            change_flag = max(map(lambda x, y: abs(x - y),
            [x1, x2, x3], previous_xs)) < epsilon

            if drawing:
                plt.plot([x1, x3], [max(f(x1), f(x3)), max(f(x1), f(x3))],
                         color='xkcd:heather')

                plt.axvline(x=min(x1, x3), color='xkcd:sage', ls='--')
                plt.axvline(x=max(x1, x3), color='xkcd:light grey green', ls='--')

            if abs(x3 - x1) < epsilon and abs(f3 - f1) < epsilon or change_flag:
                if drawing:
                  plt.legend()
                  plt.show()
                  print('Searching finished successfully. code 0')
                  print(intervals)
                return {'x min': x2, 'y min': f2, 'iterations count': i,
                        'intervals': intervals, 'computations': counter}

        else:
            print('Searching finished. Max iterations have been reached. code 1')
            return {'x min': x2, 'y min': f2, 'iterations count': i,
                    'intervals': intervals, 'computations': counter}

    except Exception as e:
        print('Error with optimization. code 2')
        raise e

successive_parabolic_interpolation(f, 0.1, 6.333, 0.3, 500, True)

"""В отличие от метода золотого сечения, метод парабол обладает суперлинейной скоростью сходимости. Однако, такая высокая скорость сходимости гарантируется только в малой окрестности точки минимума $x_{\min}$. На начальных стадиях процесса оптимизации метод парабол может делать очень маленькие шаги или, наоборот, слишком большие шаги, приводящие к неустойчивым биениям. Также следует отметить, что на первой итерации метод парабол требует измерения значений функции в крайних точках интервала оптимизации. Кроме этого, сходимость метода не гарантируется, т.к. начальное приближение может не попасть в окрестность точки минимума.

### Комбинированный метод Брента

Метод Брента эффективно комбинирует метод золотого сечения и метод парабол. В данном методе на каждой итерации отслеживаются значения в шести точках (не обязательно различных): $a,c,x,w,v,u$

Точки $a,c$ задают текущий интервал поиска решения,

$x$ – точка, соответствующая наименьшему значению функции,

$w$ – точка, соответветствующая второму снизу значению функции,

$v$ – предыдущее значение $w$

В отличие от метода парабол, в методе Брента аппроксимирующая парабола строится с помощью трех наилучших точек $x, w, v $ (в случае, если эти три точки различны и значения в них также различны)

При этом минимум аппроксимирующей параболы $u$ принимается в качестве следующей точки оптимизационного процесса, если:

*   $u$ попадает внутрь интервала $[a, c]$ и отстоит от границ интервала не менее, чем на $\varepsilon$
*   $u$ отстоит от точки $x$ не более, чем на половину от длины предпредыдущего шага

Если точка $u$ отвергается, то следующая точка находится с помощью золотого сечения большего из интервалов $[a, x]$ и $[x, c]$
"""

def brent(f, a, c, epsilon, max_iter, drawing = False):
    K = (3 - math.sqrt(5)) / 2

    x = w = v = (a + c) / 2
    f_x = f_w = f_v = f(x)
    d = e = c - a

    counter = 0
    counter += 1

    intervals = pt.PrettyTable()
    intervals.field_names = ["iteration", "a", "b", "length"]
    intervals.add_row([0, a, c, d])

    if drawing:
        x__ = np.linspace(a, c, int((c - a) / epsilon))
        y__ = f(x__)

        plt.plot(x__, y__, color='xkcd:deep purple',
                 linewidth=2, label="$f(x)$")
        plt.xlabel("x")
        plt.ylabel("f(x)")
        plt.grid(True)

        plt.axvline(x=a, color='xkcd:sage', ls='--', label="$a_i$")
        plt.axvline(x=c, color='xkcd:light grey green', ls='--', label="$b_i$")
        plt.plot([a, c], [max(f(a), f(c)), max(f(a), f(c))],
                 color='xkcd:heather', label="$[a_i, b_i]$")

    try:
        for i in range(1, max_iter):
            g, e = e, d

            unique = np.unique([x, w, v, f_x, f_w, f_v])
            if len([x, w, v, f_x, f_w, f_v]) == len(unique):
                p = (x - v) ** 2 * (f_x - f_w) - (x - w) ** 2 * (f_x - f_v)
                q = 2 * ((x - v) * (f_x - f_w) - (x - w) * (f_x - f_v))

                assert p != 0, 'Searching finished. Numerator is zero. code 2'
                assert q != 0, 'Searching finished. Denominator is zero. code 2'

                u = x - p / q

                if d <= epsilon:
                  if drawing:
                      plt.legend()
                      plt.show()
                      intervals.add_row([i, min(u, x), max(u, x), d])
                      print('Searching finished successfully. code 0')
                      print(intervals)
                  return {'x min': x, 'y min': f_x, 'iterations count': i,
                          'intervals': intervals, 'computations': counter}

                if a + epsilon <= u <= c - epsilon and abs(u - x) < g / 2:
                    d = abs(u - x)
                    intervals.add_row([i, a, c, c - a])
                    if drawing:
                      plt.plot([a, c], [max(f(a), f(c)), max(f(a), f(c))],
                               color='xkcd:heather')

                      plt.axvline(x=a, color='xkcd:sage', ls='--')
                      plt.axvline(x=c, color='xkcd:light grey green', ls='--')
                    continue

            if x < (c + a) / 2:
                u = x + K * (c - x)
                d = c - x
            else:
                u = x - K * (x - a)
                d = x - a

            if abs(u - x) < epsilon:
                u = x + np.sign(u - x) * epsilon

            f_u = f(u)

            counter += 1

            if f_u <= f_x:
                if u >= x:
                    a = x
                else:
                    c = x

                v, f_v = w, f_w
                w, f_w = x, f_x
                x, f_x = u, f_u

            else:
                if u >= x:
                    c = u
                else:
                    a = u

                if f_u <= f_w or w == x:
                    v, f_v = w, f_w
                    w, f_w = u, f_u
                elif f_u <= f_v or v == x or v == w:
                    v, f_v = u, f_u

            intervals.add_row([i, a, c, d])

            if drawing:
              plt.plot([a, c], [max(f(a), f(c)), max(f(a), f(c))],
                       color='xkcd:heather')

              plt.axvline(x=a, color='xkcd:sage', ls='--')
              plt.axvline(x=c, color='xkcd:light grey green', ls='--')

        else:
            print('Searching finished. Max iterations have been reached. code 1')
            return {'x min': x, 'y min': f_x, 'iterations count': i,
                    'intervals': intervals, 'computations': counter}

    except Exception as e:
        print('Error with optimization. code 2')
        raise e

brent(f, 0.1, 6.333, 0.005, 500, True)

"""Мы избегаем биений и застопориваний метода парабол, используя гарантированно сходящийся метод Золотого сечения в невыгодных ситуациях. И при этом при хороших значениях вершины параболы у нас получается использовать суперлинейную скорость сходимости метода Брента. В отличие от метода парабол метод Брента обладает гарантированной сходимостью.

## Сравнение методов по количеству итераций и вызову функций
"""

def optimize(f, a, b, epsilon, max_iter, delta):
    methods = np.array([
        brent,
        successive_parabolic_interpolation,
        fibonacci_method,
        golden_ratio,
        dichotomy
        ])
    results = {}
    for met in methods:
        computations = []
        epsilons = []
        iterations = []

        epsilon_i = epsilon
        delta_i = delta
        while epsilon_i - delta_i >= 0:
            res = met(f, a, b, epsilon_i, max_iter)
            epsilons.append(epsilon_i)
            epsilon_i -= delta_i
            computations.append(res["computations"])
            iterations.append(res["iterations count"])

        results[met.__name__] = (epsilons, computations, iterations)

    return results

values = optimize(f, 0.1, 6.333, 0.5, 500, 0.001)

colors = {
    'brent' : 'xkcd:sage',
    'successive_parabolic_interpolation' : 'xkcd:light grey green',
    'fibonacci_method' : 'xkcd:heather',
    'golden_ratio' : 'xkcd:plum',
    'dichotomy' : 'xkcd:deep purple',
}

for method_name in values.keys():
  plt.plot(values[method_name][0], values[method_name][1],
          label = method_name, color=colors.get(method_name))

plt.title("Зависимость числа вызовов функции от точности", fontsize = 15)
plt.xlabel("$\epsilon$")
plt.ylabel("вызовы функции")
plt.legend()
plt.grid(True)
plt.show()

for method_name in values.keys():
  plt.plot(values[method_name][0], values[method_name][2],
           'o--', label=method_name, color=colors.get(method_name))

plt.title("Зависимость количества итераций от точности", fontsize = 15)
plt.xlabel("$\epsilon$")
plt.ylabel("количество итераций")
plt.legend()
plt.grid(True)
plt.show()

def get_intervals(f, a, b, epsilon, max_iter):
    methods = np.array([
    brent,
    successive_parabolic_interpolation,
    fibonacci_method,
    golden_ratio,
    dichotomy
    ])

    for met in methods:
        res = met(f, a, b, epsilon, max_iter)

        iterations = res["intervals"].get_string(fields=["iteration"],
                                     header=False, border=False).split("\n")
        iterations = list(map(int, iterations))

        length = res["intervals"].get_string(fields=["length"],
                                 header=False, border=False).split("\n")
        length = list(map(float, length))

        plt.plot(iterations, length, label=met.__name__,
                 color=colors.get(met.__name__))

    plt.title("Зависимость длины интервала от номера итерации", fontsize = 15)
    plt.xlabel("номер итерации")
    plt.ylabel("длина интервала")
    plt.legend()
    plt.grid(True)
    plt.show()

get_intervals(f, 0.1, 6.333, 0.01, 500)

"""## Тестирование алгоритмов для задач минимизации многомодальных функций

#### Метод дихотомии
"""

dichotomy(f, 0.1, 25, 0.1, 500, True)

"""#### Метод золотого сечения"""

golden_ratio(f, 0.1, 25, 0.1, 500, True)

"""#### Метод фиббоначи"""

fibonacci_method(f, 0.1, 25, 0.1, 500, True)

"""#### Метод парабол"""

successive_parabolic_interpolation(f, 0.1, 25, 0.1, 500, True)

"""#### Комбинированный метод Брента"""

brent(f, 0.1, 25, 0.1, 500, True)

"""#### Выводы
Методы показывают себя по разному на многомодальных функциях. Наличие нескольких минимумов не повлияло на сходимость методов деления отрезка, однако выбранный ими ответ различается. Метод Брента, в отличие от метода парабол, сошелся и на многомодальной функции.

## Итоги

В работе были рассмотрены различные методы одномерной оптимизации нулевого порядка. Методы деления отрезка показывают себя более надежными методами и предпочтительны тогда, когда требуется надежная работа алгоритма при неизвестной заранее форме целевой функции. Для целевых функций, близких к квадратичным, будет эффективнее использовать метод парабол, однако его сходимость не гарантируется в связи с тем, что начальное приближение может не попасть в окрестность искомого минимума. Эту проблему исправляет комбинированный метод Брента, т.к. он имеет гарантированную, но более медленную сходимость.

## Источники

1.   Васильев, Ф. П. Методы оптимизации : учебное пособие / Ф. П. Васильев. — Москва : МЦНМО, [б. г.]. — Книга 1 — 2011. — 624 с. - ISBN 978-5-94057-707-2
2.   Аттетков, А. В. Численные методы решения задач многомерной безусловной
минимизации. : методические указания / А. В. Аттетков, А. Н. Канатников,
Е. С. Тверская; под редакцией С. Б. Ткачева. — Москва : МГТУ им. Н.Э.
Баумана, [б. г.]. — Часть 1 : Методы первого и второго порядков: Методические указания по курсу «Методы оптимизации» — 2009. — 47 с.
3.  A. Ben-Tal, A. Nemirovski. Optimization IIT. Lecture Notes, 2013.
4. Поляков, В. М. Методы оптимизации: Учебное пособие / В. М. Поляков, Агаларов З. С. : Москва : ИТК "Дашков и К " - Книга 1 - 2022. - 86 с. - ISBN 978-5-394-05003-9
"""